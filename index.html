<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Poison Roulette - Multi-Stat Edition</title>
    <style>
      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(135deg, #1a1a2e, #16213e, #0f0f23);
        color: #fff;
        margin: 0;
        padding: 20px;
        min-height: 100vh;
      }

      .game-container {
        max-width: 1400px;
        margin: 0 auto;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 20px;
        padding: 30px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        min-height: calc(100vh - 40px);
        width: 95%;
      }

      h1 {
        text-align: center;
        font-size: clamp(1.5em, 4vw, 2.2em);
        margin-bottom: 20px;
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      .players-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .player {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        padding: 15px;
        text-align: center;
        transition: all 0.3s ease;
        border: 2px solid transparent;
        min-height: 80px;
      }

      .player.alive {
        border-color: #4ecdc4;
        box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
      }

      .player.eliminated {
        background: rgba(255, 107, 107, 0.2);
        border-color: #ff6b6b;
        opacity: 0.7;
      }

      .player.current-turn {
        border-color: #ffd93d;
        box-shadow: 0 0 30px rgba(255, 217, 61, 0.5);
        transform: scale(1.02);
      }

      .player-name {
        font-size: clamp(1.1em, 2.5vw, 1.3em);
        font-weight: bold;
        margin-bottom: 8px;
      }

      .health-bar {
        background: rgba(255, 255, 255, 0.2);
        height: 12px;
        border-radius: 10px;
        overflow: hidden;
        margin: 8px 0;
      }

      .health-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff6b6b, #ffd93d, #4ecdc4);
        transition: width 0.5s ease;
      }

      .stats-table {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        padding: 20px;
        margin: 20px 0;
        overflow-x: auto;
      }

      .stats-table h3 {
        color: #ffd93d;
        margin: 0 0 15px 0;
        font-size: clamp(1.1em, 2.5vw, 1.3em);
        text-align: center;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: 150px repeat(4, 1fr);
        gap: 1px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        overflow: hidden;
        min-width: 600px;
      }

      .stats-header {
        background: rgba(255, 255, 255, 0.2);
        padding: 12px 8px;
        font-weight: bold;
        text-align: center;
        font-size: clamp(0.8em, 1.8vw, 0.9em);
        color: #ffd93d;
      }

      .stats-cell {
        background: rgba(0, 0, 0, 0.2);
        padding: 10px 8px;
        text-align: center;
        font-size: clamp(0.8em, 1.8vw, 0.9em);
        transition: all 0.3s ease;
        position: relative;
      }

      .stats-cell.player-name-cell {
        font-weight: bold;
        text-align: left;
        padding-left: 12px;
      }

      .stats-cell.current-player {
        background: rgba(255, 217, 61, 0.2);
        color: #ffd93d;
        font-weight: bold;
      }

      .stats-cell.eliminated {
        opacity: 0.5;
        color: #ff6b6b;
      }

      .stat-change {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-weight: bold;
        font-size: 0.9em;
        pointer-events: none;
        z-index: 10;
      }

      .stat-change.positive {
        color: #4ecdc4;
        animation: statChangeUp 2s ease-out;
      }

      .stat-change.negative {
        color: #ff6b6b;
        animation: statChangeDown 2s ease-out;
      }

      @keyframes statChangeUp {
        0% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        50% {
          transform: translate(-50%, -80%) scale(1.2);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -100%) scale(1);
          opacity: 0;
        }
      }

      @keyframes statChangeDown {
        0% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        50% {
          transform: translate(-50%, -20%) scale(1.2);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, 0%) scale(1);
          opacity: 0;
        }
      }

      .drink-outcome-modal {
        display: none;
        position: fixed;
        z-index: 1500;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(8px);
      }

      .outcome-content {
        background: linear-gradient(135deg, #2d3436, #636e72);
        margin: 15% auto;
        padding: 40px;
        border-radius: 20px;
        width: clamp(300px, 80vw, 500px);
        text-align: center;
        border: 3px solid;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
        animation: outcomeAppear 0.5s ease-out;
      }

      .outcome-content.positive {
        border-color: #4ecdc4;
        box-shadow: 0 0 30px rgba(78, 205, 196, 0.4);
      }

      .outcome-content.negative {
        border-color: #ff6b6b;
        box-shadow: 0 0 30px rgba(255, 107, 107, 0.4);
      }

      .outcome-content.neutral {
        border-color: #74b9ff;
        box-shadow: 0 0 30px rgba(116, 185, 255, 0.4);
      }

      @keyframes outcomeAppear {
        0% {
          transform: scale(0.8);
          opacity: 0;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      .outcome-drink {
        width: 80px;
        height: 120px;
        background: linear-gradient(
          180deg,
          transparent 15%,
          #333 15%,
          #333 90%,
          #444 90%
        );
        border-radius: 10px 10px 20px 20px;
        margin: 0 auto 20px auto;
        position: relative;
        border: 3px solid #666;
      }

      .outcome-drink .drink-liquid {
        position: absolute;
        bottom: 6px;
        left: 6px;
        right: 6px;
        height: 70%;
        border-radius: 0 0 15px 15px;
        opacity: 0.9;
      }

      .outcome-title {
        font-size: 1.8em;
        font-weight: bold;
        margin-bottom: 15px;
      }

      .outcome-title.positive {
        color: #4ecdc4;
      }

      .outcome-title.negative {
        color: #ff6b6b;
      }

      .outcome-title.neutral {
        color: #74b9ff;
      }

      .outcome-description {
        font-size: 1.2em;
        margin-bottom: 25px;
        color: #ddd;
      }

      .outcome-effects {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
        gap: 15px;
        margin: 20px 0;
      }

      .effect-item {
        padding: 12px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.1);
        font-weight: bold;
      }

      .effect-item.positive {
        background: rgba(78, 205, 196, 0.2);
        color: #4ecdc4;
      }

      .effect-item.negative {
        background: rgba(255, 107, 107, 0.2);
        color: #ff6b6b;
      }

      .effect-item.neutral {
        background: rgba(116, 185, 255, 0.2);
        color: #74b9ff;
      }

      .continue-btn {
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        border: none;
        color: white;
        padding: 15px 40px;
        border-radius: 25px;
        font-size: 1.1em;
        cursor: pointer;
        font-weight: bold;
        text-transform: uppercase;
        transition: all 0.3s ease;
        margin-top: 20px;
      }

      .continue-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
      }

      .health-change {
        position: absolute;
        top: -10px;
        right: 10px;
        font-weight: bold;
        font-size: 1.2em;
        pointer-events: none;
        z-index: 10;
      }

      .health-change.positive {
        color: #4ecdc4;
        animation: healthUp 2s ease-out;
      }

      .health-change.negative {
        color: #ff6b6b;
        animation: healthDown 2s ease-out;
      }

      @keyframes healthUp {
        0% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
        50% {
          transform: translateY(-20px) scale(1.3);
          opacity: 1;
        }
        100% {
          transform: translateY(-40px) scale(1);
          opacity: 0;
        }
      }

      @keyframes healthDown {
        0% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
        50% {
          transform: translateY(-20px) scale(1.3);
          opacity: 1;
        }
        100% {
          transform: translateY(-40px) scale(1);
          opacity: 0;
        }
      }

      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 2000;
        max-width: 400px;
        pointer-events: none;
      }

      .toast {
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 12px 16px;
        margin-bottom: 10px;
        border-radius: 8px;
        border-left: 4px solid #4ecdc4;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        transform: translateX(100%);
        animation: slideIn 0.3s ease forwards;
        pointer-events: auto;
        font-size: 0.9em;
        line-height: 1.4;
      }

      .toast.danger {
        border-left-color: #ff6b6b;
        background: rgba(255, 107, 107, 0.1);
        backdrop-filter: blur(10px);
      }

      .toast.heal {
        border-left-color: #4ecdc4;
        background: rgba(78, 205, 196, 0.1);
        backdrop-filter: blur(10px);
      }

      .toast.action {
        border-left-color: #ffd93d;
        background: rgba(255, 217, 61, 0.1);
        backdrop-filter: blur(10px);
      }

      .toast.removing {
        animation: slideOut 0.3s ease forwards;
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(100%);
          opacity: 0;
        }
      }

      .drinks-container {
        display: flex;
        justify-content: center;
        gap: clamp(8px, 2vw, 15px);
        margin: 30px 0;
        flex-wrap: wrap;
        padding: 0 10px;
      }

      .drink {
        width: clamp(40px, 6vw, 50px);
        height: clamp(80px, 12vw, 120px);
        background: linear-gradient(
          180deg,
          transparent 15%,
          #333 15%,
          #333 90%,
          #444 90%
        );
        border-radius: 8px 8px 15px 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        border: 2px solid #666;
        flex-shrink: 0;
      }

      .drink:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
      }

      .drink.selected {
        border-color: #ffd93d;
        box-shadow: 0 0 20px rgba(255, 217, 61, 0.5);
        transform: translateY(-5px) scale(1.1);
      }

      .drink.neutralized {
        border-color: #74b9ff;
        box-shadow: 0 0 15px rgba(116, 185, 255, 0.5);
      }

      .drink.spiked {
        border-color: #ff6b6b;
        box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
      }

      .drink-tooltip {
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 0.85em;
        white-space: nowrap;
        z-index: 100;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        border: 1px solid rgba(255, 255, 255, 0.2);
        max-width: 300px;
        white-space: normal;
        text-align: center;
        line-height: 1.3;
      }

      .drink:hover .drink-tooltip {
        opacity: 1;
      }

      .drink-tooltip::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 6px solid transparent;
        border-top-color: rgba(0, 0, 0, 0.9);
      }

      .drink-liquid {
        position: absolute;
        bottom: 6px;
        left: 6px;
        right: 6px;
        height: 70%;
        border-radius: 0 0 12px 12px;
        opacity: 0.9;
      }

      .drink.blue .drink-liquid {
        background: linear-gradient(180deg, #74b9ff, #0984e3);
      }

      .drink.green .drink-liquid {
        background: linear-gradient(180deg, #00b894, #00a085);
      }

      .drink.yellow .drink-liquid {
        background: linear-gradient(180deg, #fdcb6e, #e17055);
      }

      .drink.red .drink-liquid {
        background: linear-gradient(180deg, #ff6b6b, #d63031);
      }

      .drink.purple .drink-liquid {
        background: linear-gradient(180deg, #a29bfe, #6c5ce7);
      }

      .drink.black .drink-liquid {
        background: linear-gradient(180deg, #636e72, #2d3436);
      }

      .controls {
        text-align: center;
        margin: 20px 0;
        padding: 0 20px;
      }

      .btn {
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        border: none;
        color: white;
        padding: clamp(12px, 3vw, 15px) clamp(20px, 5vw, 30px);
        border-radius: 25px;
        font-size: clamp(0.9em, 2.5vw, 1.1em);
        cursor: pointer;
        margin: 10px;
        transition: all 0.3s ease;
        font-weight: bold;
        text-transform: uppercase;
        min-width: 120px;
      }

      .btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
      }

      .btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
        background: linear-gradient(45deg, #666, #777);
      }

      .btn.action-available {
        background: linear-gradient(45deg, #ffd93d, #fdcb6e);
        color: #333;
        box-shadow: 0 0 20px rgba(255, 217, 61, 0.4);
        animation: actionPulse 2s ease-in-out infinite;
      }

      @keyframes actionPulse {
        0%,
        100% {
          box-shadow: 0 0 20px rgba(255, 217, 61, 0.4);
        }
        50% {
          box-shadow: 0 0 30px rgba(255, 217, 61, 0.7);
        }
      }

      .btn.secondary {
        background: linear-gradient(45deg, #74b9ff, #0984e3);
        font-size: clamp(0.8em, 2vw, 0.9em);
        padding: clamp(8px, 2vw, 10px) clamp(16px, 4vw, 20px);
      }

      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
      }

      .modal-content {
        background: linear-gradient(135deg, #2d3436, #636e72);
        margin: 5% auto;
        padding: clamp(20px, 4vw, 30px);
        border-radius: 20px;
        width: clamp(300px, 90vw, 600px);
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
        border: 2px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      }

      .close {
        color: #aaa;
        float: right;
        font-size: clamp(24px, 5vw, 28px);
        font-weight: bold;
        cursor: pointer;
        position: absolute;
        right: 20px;
        top: 15px;
      }

      .close:hover {
        color: #fff;
      }

      .action-buttons {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 15px;
        margin-top: 20px;
      }

      .action-btn {
        background: linear-gradient(45deg, #ffd93d, #fdcb6e);
        border: none;
        color: #333;
        padding: clamp(12px, 3vw, 15px) clamp(16px, 3vw, 20px);
        border-radius: 15px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s ease;
        text-align: center;
        font-size: clamp(0.8em, 2vw, 0.9em);
        min-height: 80px;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      .action-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
      }

      .action-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .turn-order {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 10px;
        margin: 20px 0;
        text-align: center;
      }

      .turn-order h3 {
        margin: 0 0 10px 0;
        color: #ffd93d;
        font-size: clamp(1em, 2.5vw, 1.1em);
      }

      .game-log {
        display: none;
      }

      .winner-announcement {
        text-align: center;
        font-size: clamp(1.5em, 4vw, 2em);
        color: #4ecdc4;
        background: rgba(78, 205, 196, 0.1);
        padding: 20px;
        border-radius: 15px;
        margin: 20px 0;
        border: 2px solid #4ecdc4;
        display: none;
      }

      .help-btn {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: clamp(45px, 8vw, 50px);
        height: clamp(45px, 8vw, 50px);
        border-radius: 50%;
        background: linear-gradient(45deg, #74b9ff, #0984e3);
        border: none;
        color: white;
        font-size: clamp(16px, 3vw, 20px);
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }

      .help-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      }

      /* Tablet Breakpoints */
      @media (max-width: 991px) {
        .game-container {
          padding: 20px;
          margin: 10px;
          width: calc(100% - 20px);
        }

        .players-grid {
          grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
          gap: 15px;
        }

        .stats-table {
          padding: 15px;
        }

        .stats-grid {
          grid-template-columns: 120px repeat(4, 1fr);
          min-width: 500px;
        }

        .drinks-container {
          gap: 10px;
          justify-content: center;
        }

        .modal-content {
          margin: 10% auto;
          width: 95%;
        }

        .action-buttons {
          grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
          gap: 10px;
        }

        .toast-container {
          right: 10px;
          max-width: 350px;
        }
      }

      /* Mobile Breakpoints */
      @media (max-width: 767px) {
        body {
          padding: 10px;
        }

        .game-container {
          padding: 15px;
          border-radius: 15px;
          margin: 0;
          width: 100%;
          min-height: calc(100vh - 20px);
        }

        .players-grid {
          grid-template-columns: repeat(2, 1fr);
          gap: 12px;
          margin-bottom: 20px;
        }

        .player {
          padding: 12px;
          min-height: 70px;
        }

        .player.current-turn {
          transform: scale(1.01);
        }

        .stats-table {
          padding: 12px;
          margin: 15px 0;
        }

        .stats-grid {
          grid-template-columns: 100px repeat(4, 1fr);
          min-width: 400px;
          font-size: 0.8em;
        }

        .stats-header,
        .stats-cell {
          padding: 8px 4px;
          font-size: 0.75em;
        }

        .drinks-container {
          gap: 8px;
          margin: 20px 0;
          padding: 0 5px;
        }

        .drink {
          width: 35px;
          height: 70px;
        }

        .controls {
          margin: 15px 0;
          padding: 0 10px;
        }

        .btn {
          display: block;
          width: 100%;
          max-width: 300px;
          margin: 10px auto;
          padding: 15px 20px;
        }

        .turn-order {
          padding: 12px;
          font-size: 0.9em;
        }

        .modal-content {
          margin: 5% auto;
          padding: 20px;
          width: 95%;
          max-height: 85vh;
        }

        .action-buttons {
          grid-template-columns: 1fr;
          gap: 12px;
        }

        .action-btn {
          min-height: 70px;
          padding: 12px;
        }

        .help-btn {
          bottom: 15px;
          right: 15px;
          width: 45px;
          height: 45px;
        }

        .toast-container {
          top: 10px;
          right: 10px;
          left: 10px;
          max-width: none;
        }

        .toast {
          font-size: 0.85em;
          padding: 10px 12px;
        }
      }

      /* Large Desktop Optimization */
      @media (min-width: 1400px) {
        .game-container {
          max-width: 1600px;
          padding: 40px;
        }

        .players-grid {
          grid-template-columns: repeat(4, 1fr);
          gap: 25px;
        }

        .drinks-container {
          gap: 20px;
        }
      }

      /* Ultra-wide Support */
      @media (min-width: 1920px) {
        .game-container {
          max-width: 1800px;
        }
      }

      /* Touch Device Optimizations */
      @media (hover: none) and (pointer: coarse) {
        .drink:hover {
          transform: none;
          box-shadow: none;
        }

        .btn:hover {
          transform: none;
        }

        .action-btn:hover {
          transform: none;
        }

        .help-btn:hover {
          transform: none;
        }

        .drink {
          min-width: 40px;
          min-height: 80px;
        }

        .btn {
          min-height: 50px;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <h1>🥂☠️ Poison Roulette ☠️🥂</h1>

      <div class="turn-order">
        <h3>Turn Order (Speed Based)</h3>
        <div id="turn-order-display"></div>
      </div>

      <div class="players-grid" id="players-grid">
        <!-- Players will be generated here -->
      </div>

      <div class="stats-table">
        <h3>📊 Player Statistics</h3>
        <div class="stats-grid" id="stats-grid">
          <div class="stats-header">Player</div>
          <div class="stats-header">⚡ Speed</div>
          <div class="stats-header">🛡️ Shield</div>
          <div class="stats-header">🔧 Sabotage</div>
          <div class="stats-header">☠️ Toxin</div>
          <!-- Player stats will be generated here -->
        </div>
      </div>

      <div class="drinks-container" id="drinks-container">
        <!-- Drinks will be generated here -->
      </div>

      <div class="controls">
        <button
          class="btn"
          id="drink-btn"
          onclick="drinkSelected()"
          style="display: none"
        >
          Select a Drink
        </button>
        <button
          class="btn"
          id="action-btn"
          onclick="openActionModal()"
          style="display: none"
        >
          ACTIONS
        </button>
        <button
          class="btn"
          id="new-game-btn"
          onclick="startNewGame()"
          style="display: none"
        >
          New Game
        </button>
      </div>

      <div class="winner-announcement" id="winner-announcement">
        <div id="winner-text"></div>
      </div>

      <div class="toast-container" id="toast-container">
        <!-- Toast notifications will appear here -->
      </div>

      <!-- Drink Outcome Modal -->
      <div id="outcome-modal" class="drink-outcome-modal">
        <div class="outcome-content" id="outcome-content">
          <div class="outcome-drink" id="outcome-drink">
            <div class="drink-liquid" id="outcome-liquid"></div>
          </div>
          <div class="outcome-title" id="outcome-title"></div>
          <div class="outcome-description" id="outcome-description"></div>
          <div class="outcome-effects" id="outcome-effects"></div>
          <button class="continue-btn" onclick="closeOutcomeModal()">
            Continue
          </button>
        </div>
      </div>
    </div>

    <!-- Action Selection Modal -->
    <div id="action-modal" class="modal">
      <div class="modal-content">
        <span class="close" onclick="closeActionModal()">&times;</span>
        <h3>🎯 Choose Your Action</h3>
        <div class="action-buttons" id="action-buttons">
          <!-- Action buttons will be generated here -->
        </div>
      </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="modal">
      <div class="modal-content">
        <span class="close" onclick="closeHelpModal()">&times;</span>
        <div class="drink-legend">
          <div class="legend-title">Drink Effects Guide</div>

          <div class="legend-row">
            <span style="color: #74b9ff">🔵 Blue Elixir:</span> +5❤️ -2⚡ -1🔧
            (Safe but makes you slow and powerless)
          </div>

          <div class="legend-row">
            <span style="color: #00b894">🟢 Green Brew:</span> 70% chance for
            good effects (+15❤️ +1⚡ +1🔧), 30% mild poison (-8❤️ +2🔧 +1☠️)
          </div>

          <div class="legend-row">
            <span style="color: #fdcb6e">🟡 Yellow Mixture:</span> 50/50 gamble
            - either big boost (+20❤️ +2⚡) or painful lesson (-10❤️ +3🔧 +1☠️)
          </div>

          <div class="legend-row">
            <span style="color: #ff6b6b">🔴 Red Potion:</span> 30% heroic power
            (+25❤️ +1⚡ +1🛡️), 70% brutal punishment (-20❤️ +5🔧 +2☠️)
          </div>

          <div class="legend-row">
            <span style="color: #a29bfe">🟣 Purple Draught:</span> 25% mystical
            enhancement (+35❤️ +3⚡ +2🛡️), 75% cursed revenge (-25❤️ -1⚡ +8🔧
            +3☠️)
          </div>

          <div class="legend-row">
            <span style="color: #636e72">⚫ Black Essence:</span> 20% ultimate
            power (+40❤️ +4⚡ +3🛡️ + steal 10❤️), 80% near death (-35❤️ -2⚡
            +1🛡️ +12🔧 +4☠️)
          </div>

          <div
            style="
              margin-top: 20px;
              padding-top: 15px;
              border-top: 1px solid rgba(255, 255, 255, 0.2);
              font-size: 0.85em;
            "
          >
            <strong>Stats Explained:</strong><br />
            ❤️ Health | ⚡ Speed (turn order) | 🛡️ Shield (damage reduction) |
            🔧 Sabotage (action currency) | ☠️ Toxin (cumulative damage)
          </div>

          <div style="margin-top: 15px; font-size: 0.85em">
            <strong>Actions:</strong> Duplicate, Neutralize, Eliminate, Analyze,
            or Spike drinks using 🔧 Sabotage points
          </div>
        </div>
      </div>
    </div>

    <button class="help-btn" onclick="openHelpModal()">?</button>

    <script>
      let gameState = {
        players: [
          {
            name: "You",
            health: 100,
            speed: 0,
            shield: 0,
            sabotage: 0,
            toxin: 0,
            alive: true,
            isHuman: true,
          },
          {
            name: "AI Alpha",
            health: 100,
            speed: 0,
            shield: 0,
            sabotage: 0,
            toxin: 0,
            alive: true,
            isHuman: false,
          },
          {
            name: "AI Beta",
            health: 100,
            speed: 0,
            shield: 0,
            sabotage: 0,
            toxin: 0,
            alive: true,
            isHuman: false,
          },
          {
            name: "AI Gamma",
            health: 100,
            speed: 0,
            shield: 0,
            sabotage: 0,
            toxin: 0,
            alive: true,
            isHuman: false,
          },
        ],
        currentPlayerIndex: 0,
        round: 1,
        drinks: [],
        selectedDrink: null,
        gameOver: false,
        phase: "drinking",
        turnOrder: [],
      };

      const drinkEffects = {
        blue: {
          outcomes: [
            {
              chance: 100,
              health: 5,
              speed: -2,
              shield: 0,
              sabotage: -1,
              toxin: 0,
              description: "Safe but sluggish",
            },
          ],
        },
        green: {
          outcomes: [
            {
              chance: 70,
              health: 15,
              speed: 1,
              shield: 0,
              sabotage: 1,
              toxin: 0,
              description: "Refreshing boost!",
            },
            {
              chance: 30,
              health: -8,
              speed: 0,
              shield: 0,
              sabotage: 2,
              toxin: 1,
              description: "Mild poison, but you learned something",
            },
          ],
        },
        yellow: {
          outcomes: [
            {
              chance: 50,
              health: 20,
              speed: 2,
              shield: 0,
              sabotage: 0,
              toxin: 0,
              description: "Lucky break!",
            },
            {
              chance: 50,
              health: -10,
              speed: 0,
              shield: 0,
              sabotage: 3,
              toxin: 1,
              description: "Painful lesson",
            },
          ],
        },
        red: {
          outcomes: [
            {
              chance: 30,
              health: 25,
              speed: 1,
              shield: 1,
              sabotage: 0,
              toxin: 0,
              description: "Heroic power surge!",
            },
            {
              chance: 70,
              health: -20,
              speed: 0,
              shield: 0,
              sabotage: 5,
              toxin: 2,
              description: "Brutal but empowering",
            },
          ],
        },
        purple: {
          outcomes: [
            {
              chance: 25,
              health: 35,
              speed: 3,
              shield: 2,
              sabotage: 0,
              toxin: 0,
              description: "Mystical enhancement!",
            },
            {
              chance: 75,
              health: -25,
              speed: -1,
              shield: 0,
              sabotage: 8,
              toxin: 3,
              description: "Cursed but vengeful",
            },
          ],
        },
        black: {
          outcomes: [
            {
              chance: 20,
              health: 40,
              speed: 4,
              shield: 3,
              sabotage: 0,
              toxin: 0,
              description: "DEATH DEFIED! Ultimate power!",
              steal: 10,
            },
            {
              chance: 80,
              health: -35,
              speed: -2,
              shield: 1,
              sabotage: 12,
              toxin: 4,
              description: "Near death, but ultimate vengeance",
            },
          ],
        },
      };

      const actions = [
        {
          id: "duplicate",
          name: "Duplicate",
          cost: 2,
          description: "Create a copy of selected drink",
        },
        {
          id: "neutralize",
          name: "Neutralize",
          cost: 3,
          description: "Make drink give +5 health only",
        },
        {
          id: "eliminate",
          name: "Eliminate",
          cost: 2,
          description: "Remove drink from play",
        },
        {
          id: "analyze",
          name: "Analyze",
          cost: 4,
          description: "Reveal exact effects of drink",
        },
        {
          id: "spike",
          name: "Spike",
          cost: 3,
          description: "Add +15 damage to drink",
        },
      ];

      function initializeGame() {
        generateDrinks();
        updateTurnOrder();
        updateDisplay();
        startDrinkingPhase();
        showToast(
          "Game started! Everyone begins with 0 action points - drink to earn them!"
        );
      }

      function generateDrinks() {
        gameState.drinks = [];
        const colors = ["blue", "green", "yellow", "red", "purple", "black"];

        // First round: 8 drinks, subsequent rounds: 10 drinks
        const numDrinks = gameState.round === 1 ? 8 : 10;

        for (let i = 0; i < numDrinks; i++) {
          const color = colors[Math.floor(Math.random() * colors.length)];
          gameState.drinks.push({
            id: gameState.drinks.length,
            color: color,
            name: `${color.charAt(0).toUpperCase() + color.slice(1)} Elixir`,
            consumed: false,
            neutralized: false,
            spiked: false,
            analyzed: false,
            effects: null,
          });
        }
      }

      function updateTurnOrder() {
        gameState.turnOrder = gameState.players
          .filter((p) => p.alive)
          .sort((a, b) => b.speed - a.speed)
          .map((p) => p.name);

        const display = document.getElementById("turn-order-display");
        display.textContent = gameState.turnOrder.join(" → ");
      }

      function updateDisplay() {
        updatePlayers();
        updateStatsTable();
        updateDrinks();
        updateControls();
        updateTurnOrder();
      }

      function togglePlayerStats(playerIndex) {
        // Stats are now always visible in the table - this function no longer needed
      }

      function updatePlayers() {
        const grid = document.getElementById("players-grid");
        grid.innerHTML = "";

        gameState.players.forEach((player, index) => {
          const playerDiv = document.createElement("div");
          playerDiv.id = `player-${index}`;
          playerDiv.className = `player ${
            player.alive ? "alive" : "eliminated"
          }`;

          if (index === gameState.currentPlayerIndex && !gameState.gameOver) {
            playerDiv.classList.add("current-turn");
          }

          const healthPercentage = Math.max(0, Math.min(100, player.health));

          playerDiv.innerHTML = `
                    <div class="player-name">${player.name}</div>
                    <div class="health-bar">
                        <div class="health-fill" style="width: ${healthPercentage}%"></div>
                    </div>
                    <div style="margin: 8px 0; font-size: 0.9em;">Health: ${
                      player.health
                    }</div>
                    <div style="margin-top: 10px;">${
                      player.alive
                        ? index === gameState.currentPlayerIndex
                          ? "🎯 Active Turn"
                          : "⚡ Ready"
                        : "💀 Eliminated"
                    }</div>
                `;

          grid.appendChild(playerDiv);
        });
      }

      function updateStatsTable() {
        const statsGrid = document.getElementById("stats-grid");

        // Clear existing player rows (keep headers)
        const existingRows = statsGrid.querySelectorAll(".stats-cell");
        existingRows.forEach((cell) => cell.remove());

        gameState.players.forEach((player, index) => {
          const isCurrentPlayer =
            index === gameState.currentPlayerIndex && !gameState.gameOver;
          const cellClass = `stats-cell ${
            isCurrentPlayer ? "current-player" : ""
          } ${!player.alive ? "eliminated" : ""}`;

          // Player name cell
          const nameCell = document.createElement("div");
          nameCell.className = `${cellClass} player-name-cell`;
          nameCell.textContent = player.name;
          statsGrid.appendChild(nameCell);

          // Speed cell
          const speedCell = document.createElement("div");
          speedCell.className = cellClass;
          speedCell.textContent = player.speed;
          statsGrid.appendChild(speedCell);

          // Shield cell
          const shieldCell = document.createElement("div");
          shieldCell.className = cellClass;
          shieldCell.textContent = player.shield;
          statsGrid.appendChild(shieldCell);

          // Sabotage cell
          const sabotageCell = document.createElement("div");
          sabotageCell.className = cellClass;
          sabotageCell.textContent = player.sabotage;
          statsGrid.appendChild(sabotageCell);

          // Toxin cell
          const toxinCell = document.createElement("div");
          toxinCell.className = cellClass;
          toxinCell.textContent = player.toxin;
          statsGrid.appendChild(toxinCell);
        });
      }

      function updateDrinks() {
        const container = document.getElementById("drinks-container");
        container.innerHTML = "";

        gameState.drinks.forEach((drink) => {
          if (!drink.consumed) {
            const drinkDiv = document.createElement("div");
            let classes = `drink ${drink.color}`;
            if (drink.id === gameState.selectedDrink) classes += " selected";
            if (drink.neutralized) classes += " neutralized";
            if (drink.spiked) classes += " spiked";

            drinkDiv.className = classes;
            drinkDiv.onclick = () => selectDrink(drink.id);

            // Create tooltip with potion effects
            const tooltip = document.createElement("div");
            tooltip.className = "drink-tooltip";

            let tooltipContent = `<strong>${drink.name}</strong><br>`;

            if (drink.analyzed) {
              const effect = getRandomOutcome(drinkEffects[drink.color]);
              tooltipContent += `${effect.description}<br>`;
              tooltipContent += getEffectsText(effect);
            } else {
              tooltipContent += getProbabilityText(drink.color);
            }

            if (drink.neutralized)
              tooltipContent += "<br><em>Neutralized: +5 health only</em>";
            if (drink.spiked)
              tooltipContent += "<br><em>Spiked: +15 extra damage</em>";

            tooltip.innerHTML = tooltipContent;

            drinkDiv.innerHTML = `<div class="drink-liquid"></div>`;
            drinkDiv.appendChild(tooltip);
            container.appendChild(drinkDiv);
          }
        });
      }

      function getProbabilityText(color) {
        const info = {
          blue: "Safe but slow: +5❤️ -2⚡ -1🔧",
          green:
            "70% boost (+15❤️ +1⚡ +1🔧)<br>30% mild poison (-8❤️ +2🔧 +1☠️)",
          yellow: "50% lucky (+20❤️ +2⚡)<br>50% painful (-10❤️ +3🔧 +1☠️)",
          red: "30% heroic (+25❤️ +1⚡ +1🛡️)<br>70% brutal (-20❤️ +5🔧 +2☠️)",
          purple:
            "25% mystical (+35❤️ +3⚡ +2🛡️)<br>75% cursed (-25❤️ -1⚡ +8🔧 +3☠️)",
          black:
            "20% ultimate (+40❤️ +4⚡ +3🛡️ +steal)<br>80% near death (-35❤️ -2⚡ +12🔧 +4☠️)",
        };
        return info[color] || "Unknown effects";
      }

      function getEffectsText(effect) {
        const effects = [];
        if (effect.health !== 0)
          effects.push(`${effect.health > 0 ? "+" : ""}${effect.health}❤️`);
        if (effect.speed !== 0)
          effects.push(`${effect.speed > 0 ? "+" : ""}${effect.speed}⚡`);
        if (effect.shield !== 0)
          effects.push(`${effect.shield > 0 ? "+" : ""}${effect.shield}🛡️`);
        if (effect.sabotage !== 0)
          effects.push(`${effect.sabotage > 0 ? "+" : ""}${effect.sabotage}🔧`);
        if (effect.toxin !== 0)
          effects.push(`${effect.toxin > 0 ? "+" : ""}${effect.toxin}☠️`);
        if (effect.steal) effects.push(`Steal ${effect.steal}❤️`);
        return effects.join(" ");
      }

      function updateControls() {
        const drinkBtn = document.getElementById("drink-btn");
        const actionBtn = document.getElementById("action-btn");
        const newGameBtn = document.getElementById("new-game-btn");

        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        const isHumanTurn =
          currentPlayer && currentPlayer.isHuman && currentPlayer.alive;
        const hasSelection = gameState.selectedDrink !== null;
        const canUseAction = currentPlayer && currentPlayer.sabotage >= 2;

        // Show/hide buttons based on selection and turn
        if (isHumanTurn && hasSelection && !gameState.gameOver) {
          drinkBtn.style.display = "inline-block";
          actionBtn.style.display = "inline-block";

          drinkBtn.disabled = false;
          drinkBtn.textContent = "DRINK";

          if (canUseAction) {
            actionBtn.disabled = false;
            actionBtn.className = "btn action-available";
            actionBtn.textContent = "ACTIONS";
          } else {
            actionBtn.disabled = true;
            actionBtn.className = "btn";
            actionBtn.textContent = "ACTIONS";
          }
        } else {
          // Hide buttons when not human turn or no selection
          if (!isHumanTurn || gameState.gameOver) {
            drinkBtn.style.display = "none";
            actionBtn.style.display = "none";
          } else {
            // Show disabled buttons when no selection
            drinkBtn.style.display = "inline-block";
            actionBtn.style.display = "inline-block";
            drinkBtn.disabled = true;
            actionBtn.disabled = true;
            drinkBtn.textContent = "Select a Drink";
            actionBtn.textContent = "ACTIONS";
            actionBtn.className = "btn";
          }
        }

        newGameBtn.style.display = gameState.gameOver ? "inline-block" : "none";
      }

      function selectDrink(drinkId) {
        if (gameState.gameOver) return;

        gameState.selectedDrink = drinkId;
        updateDisplay();

        // No longer auto-open action modal - player must click ACTION button
      }

      function openActionModal() {
        if (gameState.selectedDrink === null) return;

        const modal = document.getElementById("action-modal");
        const actionButtons = document.getElementById("action-buttons");
        const currentPlayer = gameState.players[gameState.currentPlayerIndex];

        actionButtons.innerHTML = "";

        // Add action options
        actions.forEach((action) => {
          const button = document.createElement("button");
          button.className = "action-btn";
          button.innerHTML = `<strong>${action.name}</strong><br>${action.cost} 🔧<br><small>${action.description}</small>`;
          button.disabled = currentPlayer.sabotage < action.cost;
          button.onclick = () => {
            performAction(action.id);
            closeActionModal();
          };
          actionButtons.appendChild(button);
        });

        modal.style.display = "block";
      }

      function closeActionModal() {
        document.getElementById("action-modal").style.display = "none";
      }

      function openHelpModal() {
        document.getElementById("help-modal").style.display = "block";
      }

      function closeHelpModal() {
        document.getElementById("help-modal").style.display = "none";
      }

      function startActionPhase() {
        gameState.phase = "action";
        gameState.currentPlayerIndex = 0;
        gameState.players.forEach((p) => (p.hasActed = false));

        const firstPlayer = gameState.players.find(
          (p) => p.name === gameState.turnOrder[0]
        );
        gameState.currentPlayerIndex = gameState.players.indexOf(firstPlayer);

        updateDisplay();

        if (!gameState.players[gameState.currentPlayerIndex].isHuman) {
          setTimeout(aiAction, 1000);
        }
      }

      function performAction(actionId) {
        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        const action = actions.find((a) => a.id === actionId);
        const drink = gameState.drinks.find(
          (d) => d.id === gameState.selectedDrink
        );

        if (!drink || currentPlayer.sabotage < action.cost) return;

        currentPlayer.sabotage -= action.cost;

        switch (actionId) {
          case "duplicate":
            const newDrink = { ...drink, id: gameState.drinks.length };
            gameState.drinks.push(newDrink);
            logMessage(
              `${currentPlayer.name} duplicated ${drink.name}!`,
              "action"
            );
            break;

          case "neutralize":
            drink.neutralized = true;
            logMessage(
              `${currentPlayer.name} neutralized ${drink.name}!`,
              "action"
            );
            break;

          case "eliminate":
            drink.consumed = true;
            logMessage(
              `${currentPlayer.name} eliminated ${drink.name}!`,
              "action"
            );
            break;

          case "analyze":
            drink.analyzed = true;
            logMessage(
              `${currentPlayer.name} analyzed ${drink.name}!`,
              "action"
            );
            break;

          case "spike":
            drink.spiked = true;
            logMessage(
              `${currentPlayer.name} spiked ${drink.name} with poison!`,
              "action"
            );
            break;
        }

        gameState.selectedDrink = null;
        nextTurn();
      }

      function nextActionTurn() {
        let nextIndex = -1;
        for (let i = 0; i < gameState.turnOrder.length; i++) {
          const playerName = gameState.turnOrder[i];
          const player = gameState.players.find((p) => p.name === playerName);
          if (player && player.alive && !player.hasActed) {
            nextIndex = gameState.players.indexOf(player);
            break;
          }
        }

        if (nextIndex === -1) {
          startDrinkingPhase();
          return;
        }

        gameState.currentPlayerIndex = nextIndex;
        updateDisplay();

        if (!gameState.players[gameState.currentPlayerIndex].isHuman) {
          setTimeout(aiAction, 1500);
        }
      }

      function aiAction() {
        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        if (!currentPlayer.alive || currentPlayer.hasActed) return;

        const availableDrinks = gameState.drinks.filter((d) => !d.consumed);
        if (availableDrinks.length === 0) {
          currentPlayer.hasActed = true;
          nextActionTurn();
          return;
        }

        const randomDrink =
          availableDrinks[Math.floor(Math.random() * availableDrinks.length)];
        gameState.selectedDrink = randomDrink.id;

        const affordableActions = actions.filter(
          (a) => currentPlayer.sabotage >= a.cost
        );

        if (affordableActions.length === 0 || Math.random() < 0.3) {
          currentPlayer.hasActed = true;
          gameState.selectedDrink = null;
          nextActionTurn();
        } else {
          const chosenAction =
            affordableActions[
              Math.floor(Math.random() * affordableActions.length)
            ];
          performAction(chosenAction.id);
        }
      }

      function startDrinkingPhase() {
        gameState.phase = "drinking";
        gameState.currentPlayerIndex = 0;

        // Set current player to first in turn order
        const firstPlayer = gameState.players.find(
          (p) => p.name === gameState.turnOrder[0]
        );
        gameState.currentPlayerIndex = gameState.players.indexOf(firstPlayer);

        updateDisplay();

        if (!gameState.players[gameState.currentPlayerIndex].isHuman) {
          setTimeout(aiTurn, 1000);
        }
      }

      function drinkSelected() {
        if (gameState.selectedDrink === null || gameState.gameOver) return;

        const drink = gameState.drinks.find(
          (d) => d.id === gameState.selectedDrink
        );
        const currentPlayer = gameState.players[gameState.currentPlayerIndex];

        processDrink(currentPlayer, drink);
        nextTurn();
      }

      function showToast(message, type = "") {
        const toastContainer = document.getElementById("toast-container");
        const toast = document.createElement("div");
        toast.className = `toast ${type}`;
        toast.textContent = message;

        toastContainer.appendChild(toast);

        // Auto-remove after 4 seconds
        setTimeout(() => {
          if (toast.parentNode) {
            toast.classList.add("removing");
            setTimeout(() => {
              if (toast.parentNode) {
                toastContainer.removeChild(toast);
              }
            }, 300);
          }
        }, 4000);
      }

      function processDrink(player, drink) {
        drink.consumed = true;

        let outcome;
        if (drink.neutralized) {
          outcome = {
            health: 5,
            speed: 0,
            shield: 0,
            sabotage: 0,
            toxin: 0,
            description: "Neutralized - safe",
          };
        } else {
          outcome = getRandomOutcome(drinkEffects[drink.color]);
          if (drink.spiked) {
            outcome.health -= 15;
          }
        }

        // Store old values for visual feedback
        const oldHealth = player.health;
        const oldSpeed = player.speed;
        const oldShield = player.shield;
        const oldSabotage = player.sabotage;
        const oldToxin = player.toxin;

        // Apply effects
        player.health = Math.max(
          0,
          Math.min(100, player.health + outcome.health)
        );
        player.speed = Math.max(-10, player.speed + outcome.speed);
        player.shield = Math.max(0, player.shield + outcome.shield);
        player.sabotage = Math.max(0, player.sabotage + outcome.sabotage);
        player.toxin = Math.max(0, player.toxin + outcome.toxin);

        // Handle damage reduction from shield
        if (outcome.health < 0 && player.shield > 0) {
          const damageReduced = Math.min(
            Math.abs(outcome.health),
            player.shield * 5
          );
          player.health = Math.min(100, player.health + damageReduced);
          player.shield = Math.max(
            0,
            player.shield - Math.ceil(damageReduced / 5)
          );
        }

        // Handle health stealing
        if (outcome.steal) {
          gameState.players.forEach((p) => {
            if (p !== player && p.alive) {
              const stolenHealth = Math.min(outcome.steal, p.health);
              p.health = Math.max(0, p.health - stolenHealth);
              player.health = Math.min(100, player.health + stolenHealth);
            }
          });
        }

        if (player.health <= 0) {
          player.alive = false;
        }

        // Show visual feedback
        const playerIndex = gameState.players.indexOf(player);

        // Show stat changes
        if (outcome.speed !== 0)
          showStatChange(playerIndex, "speed", outcome.speed);
        if (outcome.shield !== 0)
          showStatChange(playerIndex, "shield", outcome.shield);
        if (outcome.sabotage !== 0)
          showStatChange(playerIndex, "sabotage", outcome.sabotage);
        if (outcome.toxin !== 0)
          showStatChange(playerIndex, "toxin", outcome.toxin);

        // Show health change
        if (outcome.health !== 0) showHealthChange(playerIndex, outcome.health);

        // Show outcome modal for human player
        if (player.isHuman) {
          setTimeout(() => {
            showDrinkOutcome(player, drink, outcome);
          }, 500);
        }

        // Update display
        updateDisplay();

        gameState.selectedDrink = null;
      }

      function getRandomOutcome(drinkEffect) {
        const random = Math.random() * 100;
        let cumulative = 0;

        for (const outcome of drinkEffect.outcomes) {
          cumulative += outcome.chance;
          if (random <= cumulative) {
            return outcome;
          }
        }
        return drinkEffect.outcomes[0];
      }

      function aiTurn() {
        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        if (!currentPlayer.alive || gameState.gameOver) return;

        const availableDrinks = gameState.drinks.filter((d) => !d.consumed);
        if (availableDrinks.length === 0) {
          nextTurn();
          return;
        }

        // AI decides whether to use action or drink
        const hasActionPoints = currentPlayer.sabotage >= 2;
        const shouldUseAction = hasActionPoints && Math.random() < 0.4; // 40% chance to use action if available

        const randomDrink =
          availableDrinks[Math.floor(Math.random() * availableDrinks.length)];
        gameState.selectedDrink = randomDrink.id;

        if (shouldUseAction) {
          // Use random action
          const affordableActions = actions.filter(
            (a) => currentPlayer.sabotage >= a.cost
          );
          if (affordableActions.length > 0) {
            const chosenAction =
              affordableActions[
                Math.floor(Math.random() * affordableActions.length)
              ];
            logMessage(
              `${currentPlayer.name} uses ${chosenAction.name} on ${randomDrink.name}!`,
              "action"
            );
            performAction(chosenAction.id);
            return;
          }
        }

        // Just drink
        logMessage(`${currentPlayer.name} drinks ${randomDrink.name}...`);
        processDrink(currentPlayer, randomDrink);
        setTimeout(nextTurn, 1000);
      }

      function getDrinkRiskScore(color, neutralized, spiked) {
        if (neutralized) return 0;

        const riskMap = {
          blue: 1,
          green: 2,
          yellow: 3,
          red: 4,
          purple: 5,
          black: 6,
        };
        let risk = riskMap[color] || 3;
        if (spiked) risk += 2;
        return risk;
      }

      function nextTurn() {
        // Apply toxin damage at end of turn
        const currentPlayer = gameState.players[gameState.currentPlayerIndex];
        if (currentPlayer.toxin > 0) {
          const toxinDamage = Math.floor(currentPlayer.toxin / 2);
          currentPlayer.health = Math.max(
            0,
            currentPlayer.health - toxinDamage
          );
          currentPlayer.toxin = Math.max(0, currentPlayer.toxin - 1);

          if (toxinDamage > 0) {
            logMessage(
              `${currentPlayer.name} takes ${toxinDamage} toxin damage!`,
              "danger"
            );
          }

          if (currentPlayer.health <= 0) {
            currentPlayer.alive = false;
          }
        }

        // Check win condition
        const alivePlayers = gameState.players.filter((p) => p.alive);
        if (alivePlayers.length <= 1) {
          endGame();
          return;
        }

        // Find next player in turn order
        let nextIndex = -1;
        const currentTurnIndex = gameState.turnOrder.indexOf(
          currentPlayer.name
        );

        for (let i = 1; i < gameState.turnOrder.length; i++) {
          const nextPlayerName =
            gameState.turnOrder[
              (currentTurnIndex + i) % gameState.turnOrder.length
            ];
          const nextPlayer = gameState.players.find(
            (p) => p.name === nextPlayerName
          );
          if (nextPlayer && nextPlayer.alive) {
            nextIndex = gameState.players.indexOf(nextPlayer);
            break;
          }
        }

        if (
          nextIndex === -1 ||
          nextIndex ===
            gameState.players.indexOf(
              gameState.players.find((p) => p.name === gameState.turnOrder[0])
            )
        ) {
          // Round complete
          gameState.round++;
          if (gameState.drinks.filter((d) => !d.consumed).length === 0) {
            generateDrinks();
            logMessage("New drinks prepared for the next round!");
          }

          // Reset to first player in turn order
          const firstPlayer = gameState.players.find(
            (p) => p.name === gameState.turnOrder[0]
          );
          gameState.currentPlayerIndex = gameState.players.indexOf(firstPlayer);
        } else {
          gameState.currentPlayerIndex = nextIndex;
        }

        updateDisplay();

        if (!gameState.players[gameState.currentPlayerIndex].isHuman) {
          setTimeout(aiTurn, 1500);
        }
      }

      function endGame() {
        gameState.gameOver = true;
        const alivePlayers = gameState.players.filter((p) => p.alive);
        const winnerDiv = document.getElementById("winner-announcement");
        const winnerText = document.getElementById("winner-text");

        if (alivePlayers.length === 1) {
          winnerText.textContent = `🏆 ${alivePlayers[0].name} WINS! 🏆`;
          logMessage(
            `Game Over! ${alivePlayers[0].name} mastered all stats and survived!`,
            "heal"
          );
        } else {
          winnerText.textContent = "💀 Total Elimination! 💀";
          logMessage("Game Over! Everyone has been eliminated!", "danger");
        }

        winnerDiv.style.display = "block";
        winnerDiv.classList.add("pulse");
        updateDisplay();
      }

      function startNewGame() {
        gameState = {
          players: [
            {
              name: "You",
              health: 100,
              speed: 0,
              shield: 0,
              sabotage: 0,
              toxin: 0,
              alive: true,
              isHuman: true,
            },
            {
              name: "AI Alpha",
              health: 100,
              speed: 0,
              shield: 0,
              sabotage: 0,
              toxin: 0,
              alive: true,
              isHuman: false,
            },
            {
              name: "AI Beta",
              health: 100,
              speed: 0,
              shield: 0,
              sabotage: 0,
              toxin: 0,
              alive: true,
              isHuman: false,
            },
            {
              name: "AI Gamma",
              health: 100,
              speed: 0,
              shield: 0,
              sabotage: 0,
              toxin: 0,
              alive: true,
              isHuman: false,
            },
          ],
          currentPlayerIndex: 0,
          round: 1,
          drinks: [],
          selectedDrink: null,
          gameOver: false,
          phase: "drinking",
          turnOrder: [],
        };

        document.getElementById("winner-announcement").style.display = "none";
        closeHelpModal();

        // Clear any existing toasts
        const toastContainer = document.getElementById("toast-container");
        toastContainer.innerHTML = "";

        initializeGame();
      }

      function showStatChange(playerIndex, stat, change) {
        const statsGrid = document.getElementById("stats-grid");
        const statIndex = { speed: 1, shield: 2, sabotage: 3, toxin: 4 }[stat];
        if (!statIndex) return;

        const cellIndex = playerIndex * 5 + statIndex; // 5 columns per player
        const cells = statsGrid.querySelectorAll(".stats-cell");
        const targetCell = cells[cellIndex];

        if (targetCell && change !== 0) {
          const changeElement = document.createElement("div");
          changeElement.className = `stat-change ${
            change > 0 ? "positive" : "negative"
          }`;
          changeElement.textContent = `${change > 0 ? "+" : ""}${change}`;

          targetCell.style.position = "relative";
          targetCell.appendChild(changeElement);

          setTimeout(() => {
            if (changeElement.parentNode) {
              targetCell.removeChild(changeElement);
            }
          }, 2000);
        }
      }

      function showHealthChange(playerIndex, change) {
        const playerCard = document.getElementById(`player-${playerIndex}`);
        if (playerCard && change !== 0) {
          const changeElement = document.createElement("div");
          changeElement.className = `health-change ${
            change > 0 ? "positive" : "negative"
          }`;
          changeElement.textContent = `${change > 0 ? "+" : ""}${change}`;

          playerCard.style.position = "relative";
          playerCard.appendChild(changeElement);

          setTimeout(() => {
            if (changeElement.parentNode) {
              playerCard.removeChild(changeElement);
            }
          }, 2000);
        }
      }

      function showDrinkOutcome(player, drink, outcome) {
        const modal = document.getElementById("outcome-modal");
        const content = document.getElementById("outcome-content");
        const drinkElement = document.getElementById("outcome-drink");
        const liquidElement = document.getElementById("outcome-liquid");
        const title = document.getElementById("outcome-title");
        const description = document.getElementById("outcome-description");
        const effects = document.getElementById("outcome-effects");

        // Set drink appearance
        drinkElement.className = `outcome-drink ${drink.color}`;
        liquidElement.className = `drink-liquid`;

        // Determine outcome type
        let outcomeType = "neutral";
        if (outcome.health > 0 || outcome.speed > 0 || outcome.shield > 0) {
          outcomeType = "positive";
        } else if (outcome.health < 0 || outcome.toxin > 0) {
          outcomeType = "negative";
        }

        content.className = `outcome-content ${outcomeType}`;
        title.className = `outcome-title ${outcomeType}`;

        // Set content
        title.textContent = `${player.name} drank ${drink.name}!`;
        description.textContent = outcome.description;

        // Show effects
        effects.innerHTML = "";
        const effectsToShow = [
          { label: "❤️ Health", value: outcome.health },
          { label: "⚡ Speed", value: outcome.speed },
          { label: "🛡️ Shield", value: outcome.shield },
          { label: "🔧 Sabotage", value: outcome.sabotage },
          { label: "☠️ Toxin", value: outcome.toxin },
        ].filter((effect) => effect.value !== 0);

        effectsToShow.forEach((effect) => {
          const effectDiv = document.createElement("div");
          const effectType = effect.value > 0 ? "positive" : "negative";
          effectDiv.className = `effect-item ${effectType}`;
          effectDiv.innerHTML = `${effect.label}<br>${
            effect.value > 0 ? "+" : ""
          }${effect.value}`;
          effects.appendChild(effectDiv);
        });

        if (outcome.steal) {
          const stealDiv = document.createElement("div");
          stealDiv.className = "effect-item positive";
          stealDiv.innerHTML = `💀 Steal<br>+${outcome.steal} from all`;
          effects.appendChild(stealDiv);
        }

        modal.style.display = "block";
      }

      function closeOutcomeModal() {
        document.getElementById("outcome-modal").style.display = "none";
      }

      function logMessage(message, className = "") {
        showToast(message, className);
      }

      // Close modals when clicking outside
      window.onclick = function (event) {
        const actionModal = document.getElementById("action-modal");
        const helpModal = document.getElementById("help-modal");
        const outcomeModal = document.getElementById("outcome-modal");
        if (event.target === actionModal) {
          closeActionModal();
        }
        if (event.target === helpModal) {
          closeHelpModal();
        }
        if (event.target === outcomeModal) {
          closeOutcomeModal();
        }
      };

      // Initialize the game
      initializeGame();
    </script>
  </body>
</html>
